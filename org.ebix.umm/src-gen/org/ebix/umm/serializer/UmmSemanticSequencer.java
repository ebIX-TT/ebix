/*
 * generated by Xtext
 */
package org.ebix.umm.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.ebix.umm.services.UmmGrammarAccess;
import org.ebix.umm.umm.ABIE;
import org.ebix.umm.umm.ACC;
import org.ebix.umm.umm.ASBIE;
import org.ebix.umm.umm.ASCC;
import org.ebix.umm.umm.ASMA;
import org.ebix.umm.umm.ASNONE;
import org.ebix.umm.umm.Assembled;
import org.ebix.umm.umm.BBIE;
import org.ebix.umm.umm.BCC;
import org.ebix.umm.umm.BDT;
import org.ebix.umm.umm.BDTLibrary;
import org.ebix.umm.umm.BIELibrary;
import org.ebix.umm.umm.CCLibrary;
import org.ebix.umm.umm.CDT;
import org.ebix.umm.umm.CDTLibrary;
import org.ebix.umm.umm.CDT_Content;
import org.ebix.umm.umm.CDT_Supplement;
import org.ebix.umm.umm.CodelistEntry;
import org.ebix.umm.umm.Constraint;
import org.ebix.umm.umm.Content;
import org.ebix.umm.umm.DocLibrary;
import org.ebix.umm.umm.ENUMLibrary;
import org.ebix.umm.umm.InfEnvelope;
import org.ebix.umm.umm.MA;
import org.ebix.umm.umm.OclAnd;
import org.ebix.umm.umm.OclArrow;
import org.ebix.umm.umm.OclBooleanFalse;
import org.ebix.umm.umm.OclBooleanTrue;
import org.ebix.umm.umm.OclEnumerationLiteral;
import org.ebix.umm.umm.OclEqual;
import org.ebix.umm.umm.OclForAll;
import org.ebix.umm.umm.OclImplies;
import org.ebix.umm.umm.OclIntegerLiteral;
import org.ebix.umm.umm.OclInvariant;
import org.ebix.umm.umm.OclIsEmpty;
import org.ebix.umm.umm.OclLess;
import org.ebix.umm.umm.OclLessOrEqual;
import org.ebix.umm.umm.OclMore;
import org.ebix.umm.umm.OclMoreOrEqual;
import org.ebix.umm.umm.OclNotEmpty;
import org.ebix.umm.umm.OclOr;
import org.ebix.umm.umm.OclPathFeatureHead;
import org.ebix.umm.umm.OclPathSelfHead;
import org.ebix.umm.umm.OclPathTail;
import org.ebix.umm.umm.OclSize;
import org.ebix.umm.umm.OclStringLiteral;
import org.ebix.umm.umm.OclXor;
import org.ebix.umm.umm.Original;
import org.ebix.umm.umm.Primitive;
import org.ebix.umm.umm.PrimitiveLibrary;
import org.ebix.umm.umm.Subset;
import org.ebix.umm.umm.Supplement;
import org.ebix.umm.umm.TC_Constraint;
import org.ebix.umm.umm.UmmPackage;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class UmmSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UmmGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == UmmPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case UmmPackage.ABIE:
				sequence_ABIE(context, (ABIE) semanticObject); 
				return; 
			case UmmPackage.ACC:
				sequence_ACC(context, (ACC) semanticObject); 
				return; 
			case UmmPackage.ASBIE:
				sequence_ASBIE(context, (ASBIE) semanticObject); 
				return; 
			case UmmPackage.ASCC:
				sequence_ASCC(context, (ASCC) semanticObject); 
				return; 
			case UmmPackage.ASMA:
				sequence_ASMA(context, (ASMA) semanticObject); 
				return; 
			case UmmPackage.ASNONE:
				sequence_ASNONE(context, (ASNONE) semanticObject); 
				return; 
			case UmmPackage.ASSEMBLED:
				sequence_Assembled(context, (Assembled) semanticObject); 
				return; 
			case UmmPackage.BBIE:
				sequence_BBIE(context, (BBIE) semanticObject); 
				return; 
			case UmmPackage.BCC:
				sequence_BCC(context, (BCC) semanticObject); 
				return; 
			case UmmPackage.BDT:
				sequence_BDT(context, (BDT) semanticObject); 
				return; 
			case UmmPackage.BDT_LIBRARY:
				sequence_BDTLibrary(context, (BDTLibrary) semanticObject); 
				return; 
			case UmmPackage.BIE_LIBRARY:
				sequence_BIELibrary(context, (BIELibrary) semanticObject); 
				return; 
			case UmmPackage.CC_LIBRARY:
				sequence_CCLibrary(context, (CCLibrary) semanticObject); 
				return; 
			case UmmPackage.CDT:
				sequence_CDT(context, (CDT) semanticObject); 
				return; 
			case UmmPackage.CDT_LIBRARY:
				sequence_CDTLibrary(context, (CDTLibrary) semanticObject); 
				return; 
			case UmmPackage.CDT_CONTENT:
				sequence_CDT_Content(context, (CDT_Content) semanticObject); 
				return; 
			case UmmPackage.CDT_SUPPLEMENT:
				sequence_CDT_Supplement(context, (CDT_Supplement) semanticObject); 
				return; 
			case UmmPackage.CODELIST_ENTRY:
				sequence_CodelistEntry(context, (CodelistEntry) semanticObject); 
				return; 
			case UmmPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case UmmPackage.CONTENT:
				sequence_Content(context, (Content) semanticObject); 
				return; 
			case UmmPackage.DOC_LIBRARY:
				sequence_DocLibrary(context, (DocLibrary) semanticObject); 
				return; 
			case UmmPackage.ENUM_LIBRARY:
				sequence_ENUMLibrary(context, (ENUMLibrary) semanticObject); 
				return; 
			case UmmPackage.INF_ENVELOPE:
				sequence_InfEnvelope(context, (InfEnvelope) semanticObject); 
				return; 
			case UmmPackage.MA:
				sequence_MA(context, (MA) semanticObject); 
				return; 
			case UmmPackage.OCL_AND:
				sequence_OclOperationLogicAnd(context, (OclAnd) semanticObject); 
				return; 
			case UmmPackage.OCL_ARROW:
				sequence_OclOperationArrow(context, (OclArrow) semanticObject); 
				return; 
			case UmmPackage.OCL_BOOLEAN_FALSE:
				sequence_OclBooleanFalse(context, (OclBooleanFalse) semanticObject); 
				return; 
			case UmmPackage.OCL_BOOLEAN_TRUE:
				sequence_OclBooleanTrue(context, (OclBooleanTrue) semanticObject); 
				return; 
			case UmmPackage.OCL_ENUMERATION_LITERAL:
				sequence_OclEnumerationLiteral(context, (OclEnumerationLiteral) semanticObject); 
				return; 
			case UmmPackage.OCL_EQUAL:
				sequence_OclOperationLogicEqual(context, (OclEqual) semanticObject); 
				return; 
			case UmmPackage.OCL_FOR_ALL:
				sequence_OclForAll(context, (OclForAll) semanticObject); 
				return; 
			case UmmPackage.OCL_IMPLIES:
				sequence_OclOperationImplies(context, (OclImplies) semanticObject); 
				return; 
			case UmmPackage.OCL_INTEGER_LITERAL:
				sequence_OclIntegerLiteral(context, (OclIntegerLiteral) semanticObject); 
				return; 
			case UmmPackage.OCL_INVARIANT:
				sequence_OclInvariant(context, (OclInvariant) semanticObject); 
				return; 
			case UmmPackage.OCL_IS_EMPTY:
				sequence_OclIsEmpty(context, (OclIsEmpty) semanticObject); 
				return; 
			case UmmPackage.OCL_LESS:
				sequence_OclOperationLogicCompare(context, (OclLess) semanticObject); 
				return; 
			case UmmPackage.OCL_LESS_OR_EQUAL:
				sequence_OclOperationLogicCompare(context, (OclLessOrEqual) semanticObject); 
				return; 
			case UmmPackage.OCL_MORE:
				sequence_OclOperationLogicCompare(context, (OclMore) semanticObject); 
				return; 
			case UmmPackage.OCL_MORE_OR_EQUAL:
				sequence_OclOperationLogicCompare(context, (OclMoreOrEqual) semanticObject); 
				return; 
			case UmmPackage.OCL_NOT_EMPTY:
				sequence_OclNotEmpty(context, (OclNotEmpty) semanticObject); 
				return; 
			case UmmPackage.OCL_OR:
				sequence_OclOperationLogicOr(context, (OclOr) semanticObject); 
				return; 
			case UmmPackage.OCL_PATH_FEATURE_HEAD:
				sequence_OclPathFeatureHead(context, (OclPathFeatureHead) semanticObject); 
				return; 
			case UmmPackage.OCL_PATH_SELF_HEAD:
				sequence_OclPathSelfHead(context, (OclPathSelfHead) semanticObject); 
				return; 
			case UmmPackage.OCL_PATH_TAIL:
				sequence_OclPathTail(context, (OclPathTail) semanticObject); 
				return; 
			case UmmPackage.OCL_SIZE:
				sequence_OclSize(context, (OclSize) semanticObject); 
				return; 
			case UmmPackage.OCL_STRING_LITERAL:
				sequence_OclStringLiteral(context, (OclStringLiteral) semanticObject); 
				return; 
			case UmmPackage.OCL_XOR:
				sequence_OclOperationLogicXor(context, (OclXor) semanticObject); 
				return; 
			case UmmPackage.ORIGINAL:
				sequence_Original(context, (Original) semanticObject); 
				return; 
			case UmmPackage.PRIMITIVE:
				sequence_Primitive(context, (Primitive) semanticObject); 
				return; 
			case UmmPackage.PRIMITIVE_LIBRARY:
				sequence_PrimitiveLibrary(context, (PrimitiveLibrary) semanticObject); 
				return; 
			case UmmPackage.SUBSET:
				sequence_Subset(context, (Subset) semanticObject); 
				return; 
			case UmmPackage.SUPPLEMENT:
				sequence_Supplement(context, (Supplement) semanticObject); 
				return; 
			case UmmPackage.TC_CONSTRAINT:
				sequence_TC_Constraint(context, (TC_Constraint) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         properties+=ABIEProperty* 
	 *         constraints+=Constraint*
	 *     )
	 */
	protected void sequence_ABIE(EObject context, ABIE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         properties+=ACCProperty* 
	 *         constraints+=Constraint*
	 *     )
	 */
	protected void sequence_ACC(EObject context, ACC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         multiplicity=MultiplicityKind 
	 *         name=ID 
	 *         type=[ABIE|ID] 
	 *         (or+=[ABIEProperty|ID] or+=[ABIEProperty|ID]*)? 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         sequencingKey=STRING
	 *     )
	 */
	protected void sequence_ASBIE(EObject context, ASBIE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         multiplicity=MultiplicityKind 
	 *         name=ID 
	 *         type=[ACC|ID] 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         sequencingKey=STRING
	 *     )
	 */
	protected void sequence_ASCC(EObject context, ASCC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID multiplicity=MultiplicityKind type=[ABIE|ID])
	 */
	protected void sequence_ASMA(EObject context, ASMA semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_REF__NAME));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_REF__MULTIPLICITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_REF__MULTIPLICITY));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.MA_PROPERTY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.MA_PROPERTY__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getASMAAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getASMAAccess().getMultiplicityMultiplicityKindEnumRuleCall_2_0(), semanticObject.getMultiplicity());
		feeder.accept(grammarAccess.getASMAAccess().getTypeABIEIDTerminalRuleCall_3_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID multiplicity=MultiplicityKind type=[ABIE|ID])
	 */
	protected void sequence_ASNONE(EObject context, ASNONE semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_REF__NAME));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_REF__MULTIPLICITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_REF__MULTIPLICITY));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.MA_PROPERTY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.MA_PROPERTY__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getASNONEAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getASNONEAccess().getMultiplicityMultiplicityKindEnumRuleCall_1_0(), semanticObject.getMultiplicity());
		feeder.accept(grammarAccess.getASNONEAccess().getTypeABIEIDTerminalRuleCall_2_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         codeListAgencyIdentifier=STRING 
	 *         codeListName=STRING 
	 *         codeListIdentifier=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         (originals+=[Original|ID] originals+=[Original|ID]*)? 
	 *         (subsets+=[Subset|ID] subsets+=[Subset|ID]*)?
	 *     )
	 */
	protected void sequence_Assembled(EObject context, Assembled semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         multiplicity=MultiplicityKind 
	 *         name=ID 
	 *         type=[BDT|ID] 
	 *         (restriction+=STRING restriction+=STRING*)? 
	 *         fixedValue=STRING? 
	 *         (or+=[ABIEProperty|ID] or+=[ABIEProperty|ID]*)? 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         sequencingKey=STRING
	 *     )
	 */
	protected void sequence_BBIE(EObject context, BBIE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         multiplicity=MultiplicityKind 
	 *         name=ID 
	 *         type=[CDT|ID] 
	 *         (restriction+=STRING restriction+=STRING*)? 
	 *         fixedValue=STRING? 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         sequencingKey=STRING
	 *     )
	 */
	protected void sequence_BCC(EObject context, BCC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         (copyright+=STRING copyright+=STRING*)? 
	 *         (owner+=STRING owner+=STRING*)? 
	 *         (reference+=STRING reference+=STRING*)? 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         baseURN=STRING 
	 *         namespacePrefix=STRING 
	 *         bdts+=BDT*
	 *     )
	 */
	protected void sequence_BDTLibrary(EObject context, BDTLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         properties+=BDTProperty*
	 *     )
	 */
	protected void sequence_BDT(EObject context, BDT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         (copyright+=STRING copyright+=STRING*)? 
	 *         (owner+=STRING owner+=STRING*)? 
	 *         (reference+=STRING reference+=STRING*)? 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         baseURN=STRING 
	 *         namespacePrefix=STRING 
	 *         bdtLibrary=[BDTLibrary|ID] 
	 *         abies+=ABIE*
	 *     )
	 */
	protected void sequence_BIELibrary(EObject context, BIELibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         (copyright+=STRING copyright+=STRING*)? 
	 *         (owner+=STRING owner+=STRING*)? 
	 *         (reference+=STRING reference+=STRING*)? 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         baseURN=STRING 
	 *         namespacePrefix=STRING 
	 *         accs+=ACC*
	 *     )
	 */
	protected void sequence_CCLibrary(EObject context, CCLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         (copyright+=STRING copyright+=STRING*)? 
	 *         (owner+=STRING owner+=STRING*)? 
	 *         (reference+=STRING reference+=STRING*)? 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         baseURN=STRING 
	 *         namespacePrefix=STRING 
	 *         cdts+=CDT*
	 *     )
	 */
	protected void sequence_CDTLibrary(EObject context, CDTLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         properties+=CDTProperty*
	 *     )
	 */
	protected void sequence_CDT(EObject context, CDT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         multiplicity=MultiplicityKind 
	 *         name=ID 
	 *         type=[Primitive|ID] 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING
	 *     )
	 */
	protected void sequence_CDT_Content(EObject context, CDT_Content semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         multiplicity=MultiplicityKind 
	 *         name=ID 
	 *         type=[Primitive|ID] 
	 *         defaultValue=STRING? 
	 *         (restriction+=STRING restriction+=STRING*)? 
	 *         fixedValue=STRING? 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING
	 *     )
	 */
	protected void sequence_CDT_Supplement(EObject context, CDT_Supplement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=STRING description=STRING)
	 */
	protected void sequence_CodelistEntry(EObject context, CodelistEntry semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.CODELIST_ENTRY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.CODELIST_ENTRY__NAME));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.CODELIST_ENTRY__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.CODELIST_ENTRY__DESCRIPTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCodelistEntryAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCodelistEntryAccess().getDescriptionSTRINGTerminalRuleCall_2_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (context=[ContextRef|ID] (type+=TC_Constraint type+=TC_Constraint*)? invariants+=OclInvariant*)
	 */
	protected void sequence_Constraint(EObject context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         multiplicity=MultiplicityKind 
	 *         name=ID 
	 *         type=[AssembledBase|ID] 
	 *         pattern=STRING? 
	 *         minLength=INT? 
	 *         maxLength=INT? 
	 *         length=INT? 
	 *         maxInclusive=INT? 
	 *         maxExclusive=INT? 
	 *         minInclusive=INT? 
	 *         minExclusive=INT? 
	 *         fractionalDigits=INT? 
	 *         totalDigits=INT? 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING
	 *     )
	 */
	protected void sequence_Content(EObject context, Content semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         (copyright+=STRING copyright+=STRING*)? 
	 *         (owner+=STRING owner+=STRING*)? 
	 *         (reference+=STRING reference+=STRING*)? 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         baseURN=STRING 
	 *         namespacePrefix=STRING 
	 *         bieLibrary=[BIELibrary|ID] 
	 *         bdtLibrary=[BDTLibrary|ID] 
	 *         envelopes+=InfEnvelope*
	 *     )
	 */
	protected void sequence_DocLibrary(EObject context, DocLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=STRING 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         (copyright+=STRING copyright+=STRING*)? 
	 *         (owner+=STRING owner+=STRING*)? 
	 *         (reference+=STRING reference+=STRING*)? 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         baseURN=STRING 
	 *         namespacePrefix=STRING 
	 *         enums+=ENUM*
	 *     )
	 */
	protected void sequence_ENUMLibrary(EObject context, ENUMLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=STRING assemblies+=MA*)
	 */
	protected void sequence_InfEnvelope(EObject context, InfEnvelope semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID properties+=MAProperty* constraints+=Constraint*)
	 */
	protected void sequence_MA(EObject context, MA semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {OclBooleanFalse}
	 */
	protected void sequence_OclBooleanFalse(EObject context, OclBooleanFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {OclBooleanTrue}
	 */
	protected void sequence_OclBooleanTrue(EObject context, OclBooleanTrue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=ENUMLIT
	 */
	protected void sequence_OclEnumerationLiteral(EObject context, OclEnumerationLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_ENUMERATION_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_ENUMERATION_LITERAL__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclEnumerationLiteralAccess().getValueENUMLITTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     body=OclExpression
	 */
	protected void sequence_OclForAll(EObject context, OclForAll semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_FOR_ALL__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_FOR_ALL__BODY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclForAllAccess().getBodyOclExpressionParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_OclIntegerLiteral(EObject context, OclIntegerLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_INTEGER_LITERAL__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclIntegerLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=OclExpression
	 */
	protected void sequence_OclInvariant(EObject context, OclInvariant semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_INVARIANT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_INVARIANT__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclInvariantAccess().getExpressionOclExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {OclIsEmpty}
	 */
	protected void sequence_OclIsEmpty(EObject context, OclIsEmpty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {OclNotEmpty}
	 */
	protected void sequence_OclNotEmpty(EObject context, OclNotEmpty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=OclOperationArrow_OclArrow_1_0 right=OclFunctionCall)
	 */
	protected void sequence_OclOperationArrow(EObject context, OclArrow semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_ARROW__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_ARROW__LEFT));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_ARROW__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_ARROW__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclOperationArrowAccess().getOclArrowLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOclOperationArrowAccess().getRightOclFunctionCallParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=OclOperationImplies_OclImplies_1_0 right=OclOperationLogicAnd)
	 */
	protected void sequence_OclOperationImplies(EObject context, OclImplies semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_IMPLIES__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_IMPLIES__LEFT));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_IMPLIES__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_IMPLIES__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclOperationImpliesAccess().getOclImpliesLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOclOperationImpliesAccess().getRightOclOperationLogicAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=OclOperationLogicAnd_OclAnd_1_0 right=OclOperationLogicOr)
	 */
	protected void sequence_OclOperationLogicAnd(EObject context, OclAnd semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_AND__LEFT));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_AND__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclOperationLogicAndAccess().getOclAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOclOperationLogicAndAccess().getRightOclOperationLogicOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=OclOperationLogicCompare_OclLess_1_0_0_0 right=OclOperationArrow)
	 */
	protected void sequence_OclOperationLogicCompare(EObject context, OclLess semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_LESS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_LESS__LEFT));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_LESS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_LESS__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclOperationLogicCompareAccess().getOclLessLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOclOperationLogicCompareAccess().getRightOclOperationArrowParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=OclOperationLogicCompare_OclLessOrEqual_1_0_1_0 right=OclOperationArrow)
	 */
	protected void sequence_OclOperationLogicCompare(EObject context, OclLessOrEqual semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_LESS_OR_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_LESS_OR_EQUAL__LEFT));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_LESS_OR_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_LESS_OR_EQUAL__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclOperationLogicCompareAccess().getOclLessOrEqualLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOclOperationLogicCompareAccess().getRightOclOperationArrowParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=OclOperationLogicCompare_OclMore_1_0_2_0 right=OclOperationArrow)
	 */
	protected void sequence_OclOperationLogicCompare(EObject context, OclMore semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_MORE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_MORE__LEFT));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_MORE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_MORE__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclOperationLogicCompareAccess().getOclMoreLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOclOperationLogicCompareAccess().getRightOclOperationArrowParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=OclOperationLogicCompare_OclMoreOrEqual_1_0_3_0 right=OclOperationArrow)
	 */
	protected void sequence_OclOperationLogicCompare(EObject context, OclMoreOrEqual semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_MORE_OR_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_MORE_OR_EQUAL__LEFT));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_MORE_OR_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_MORE_OR_EQUAL__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclOperationLogicCompareAccess().getOclMoreOrEqualLeftAction_1_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOclOperationLogicCompareAccess().getRightOclOperationArrowParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=OclOperationLogicEqual_OclEqual_1_0 right=OclOperationLogicCompare)
	 */
	protected void sequence_OclOperationLogicEqual(EObject context, OclEqual semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_EQUAL__LEFT));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_EQUAL__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclOperationLogicEqualAccess().getOclEqualLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOclOperationLogicEqualAccess().getRightOclOperationLogicCompareParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=OclOperationLogicOr_OclOr_1_0 right=OclOperationLogicXor)
	 */
	protected void sequence_OclOperationLogicOr(EObject context, OclOr semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_OR__LEFT));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_OR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclOperationLogicOrAccess().getOclOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOclOperationLogicOrAccess().getRightOclOperationLogicXorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=OclOperationLogicXor_OclXor_1_0 right=OclOperationLogicEqual)
	 */
	protected void sequence_OclOperationLogicXor(EObject context, OclXor semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_XOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_XOR__LEFT));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_XOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_XOR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclOperationLogicXorAccess().getOclXorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOclOperationLogicXorAccess().getRightOclOperationLogicEqualParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (feature=[OclRef|ID] tail=OclPathTail?)
	 */
	protected void sequence_OclPathFeatureHead(EObject context, OclPathFeatureHead semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     path=OclPathTail
	 */
	protected void sequence_OclPathSelfHead(EObject context, OclPathSelfHead semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_PATH_SELF_HEAD__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_PATH_SELF_HEAD__PATH));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclPathSelfHeadAccess().getPathOclPathTailParserRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (feature=[OclRef|ID] tail=OclPathTail?)
	 */
	protected void sequence_OclPathTail(EObject context, OclPathTail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {OclSize}
	 */
	protected void sequence_OclSize(EObject context, OclSize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_OclStringLiteral(EObject context, OclStringLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.OCL_STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.OCL_STRING_LITERAL__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOclStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         codeListAgencyIdentifier=STRING 
	 *         codeListName=STRING 
	 *         codeListIdentifier=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         codes+=CodelistEntry*
	 *     )
	 */
	protected void sequence_Original(EObject context, Original semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=STRING types+=Primitive*)
	 */
	protected void sequence_PrimitiveLibrary(EObject context, PrimitiveLibrary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             (businessTerm+=STRING businessTerm+=STRING*)? 
	 *             definition=STRING 
	 *             codeListAgencyIdentifier=STRING 
	 *             codeListName=STRING 
	 *             codeListIdentifier=STRING 
	 *             dictionary=STRING 
	 *             uniqueIdentifier=STRING 
	 *             versionIdentifier=STRING
	 *         )?
	 *     )
	 */
	protected void sequence_Primitive(EObject context, Primitive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         codeListAgencyIdentifier=STRING 
	 *         codeListName=STRING 
	 *         codeListIdentifier=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING 
	 *         codes+=CodelistEntry*
	 *     )
	 */
	protected void sequence_Subset(EObject context, Subset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         multiplicity=MultiplicityKind 
	 *         name=ID 
	 *         type=[AssembledBase|ID] 
	 *         pattern=STRING? 
	 *         minLength=INT? 
	 *         maxLength=INT? 
	 *         length=INT? 
	 *         defaultValue=STRING? 
	 *         (restriction+=STRING restriction+=STRING*)? 
	 *         fixedValue=STRING? 
	 *         (businessTerm+=STRING businessTerm+=STRING*)? 
	 *         definition=STRING 
	 *         dictionary=STRING 
	 *         uniqueIdentifier=STRING 
	 *         versionIdentifier=STRING
	 *     )
	 */
	protected void sequence_Supplement(EObject context, Supplement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (kind=ConstraintKind listIdentifier=STRING responsibleAgency=STRING)
	 */
	protected void sequence_TC_Constraint(EObject context, TC_Constraint semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.TC_CONSTRAINT__KIND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.TC_CONSTRAINT__KIND));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.TC_CONSTRAINT__LIST_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.TC_CONSTRAINT__LIST_IDENTIFIER));
			if(transientValues.isValueTransient(semanticObject, UmmPackage.Literals.TC_CONSTRAINT__RESPONSIBLE_AGENCY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UmmPackage.Literals.TC_CONSTRAINT__RESPONSIBLE_AGENCY));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTC_ConstraintAccess().getKindConstraintKindEnumRuleCall_0_0(), semanticObject.getKind());
		feeder.accept(grammarAccess.getTC_ConstraintAccess().getListIdentifierSTRINGTerminalRuleCall_4_0(), semanticObject.getListIdentifier());
		feeder.accept(grammarAccess.getTC_ConstraintAccess().getResponsibleAgencySTRINGTerminalRuleCall_8_0(), semanticObject.getResponsibleAgency());
		feeder.finish();
	}
}
